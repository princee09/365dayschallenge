106. Construct Binary Tree from Inorder and Postorder Traversal
To build a tree from inorder and postorder, just think of a tree as a family, where each person is connected to two children — a left and a right. The postorder list always tells you the last person visited, which is the root of the tree. So we take the last number from the postorder list and make it the root. Now to figure out who belongs in the left and right side of this root, we look at the inorder list. In inorder, all the values to the left of the root belong to the left subtree, and the values to the right belong to the right subtree. We then repeat this process for the left and right parts by picking the next root from the end of postorder, and again dividing the inorder list around that root. This continues until we build the full tree. To make it faster, we use a map so that we can find any number’s position in the inorder list quickly. In the end, we're just cutting the problem into smaller trees and sticking them together to recreate the original one.

297. Serialize and Deserialize Binary Tree
Serialization means turning a tree into a string, like flattening it into a sentence so it can be saved or shared. Deserialization is the reverse — turning the string back into the same exact tree. We do this by walking through the tree in a root-left-right order (called preorder). As we walk, we write down each value. If we find that a child doesn’t exist, we write # to remember that spot was empty. So for example, if the tree had a node but no left child, we still note that down with #. This way, the entire structure is saved in the string, including empty spots. Later, when we want to rebuild the tree, we read this string left to right. Every number becomes a node. Every # means there’s no node there. Using recursion, we build the left and right sides exactly as we had written them. So, just by reading the values and markers in the correct order, we grow the same original tree again.