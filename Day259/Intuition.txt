1985: Find the Kth Largest Integer in the Array

The problem is like asking you to find the third tallest person in a line, but instead of people, we have very large numbers given as strings. Because these numbers are so big they don't fit in a normal number variable, we cannot simply convert them. We have to compare them as strings.

The key to comparing number-strings is to first look at their length. A number with more digits is always larger than a number with fewer digits. For example, "1000" (4 digits) is bigger than "999" (3 digits). Only if two numbers have the same number of digits do we compare them digit by digit from left to right, just like in a dictionary.

The plan is simple. We will sort the entire list of these number-strings from the smallest to the largest. Once the list is perfectly sorted, finding the kth largest is easy. If you have a list of 10 items sorted from smallest to largest, the 1st largest is the last item (position 10), the 2nd largest is the second last (position 9), and so on. In general, for a list of n items, the kth largest item will be at the position n - k. So, after sorting, we just return the string sitting at that calculated position.



The code uses the standard sort function, which is a highly efficient sorting algorithm. The special part is the custom rule we provide for sorting, defined inside the sort function.

This rule tells the computer how to compare any two number-strings, a and b. First, it checks if their lengths are different. If a is shorter than b, it means a is a smaller number, so it should come before b in our sorted list. If the lengths are the same, it uses the built-in compare function which checks which string is lexicographically (alphabetically) smaller, which for digits of the same length correctly compares the numerical value.

After the entire array is sorted from smallest to largest, the code directly accesses the element at the index nums.size() - k and returns it, which is exactly the kth largest element we are looking for.











973: K Closest Points to Origin




Imagine you have a bunch of houses on a map, and you want to find the 3 houses that are closest to your home (the origin). The distance of each house is calculated using the Pythagorean theorem: you square the x-coordinate, square the y-coordinate, add them together. You don't need the actual distance; you can just compare this sum of squares, as a smaller sum means a shorter distance.

Checking every distance one by one would be slow. The Quickselect method is a clever way to find the k closest houses without having to sort the entire list, which saves a lot of time. It works similarly to how you might quickly find a ranking in a list.

Here is how it works step-by-step. You pick a random house from the list and call it the "pivot." Then, you rearrange all the other houses. You put all houses that are closer than the pivot to its left, and all houses that are farther away to its right. After this step, the pivot is in its correct final position in the sorted list.

Now, you know the pivot's position. If you are looking for the 3 closest houses and the pivot ends up in position 4, you know the 3 closest must all be in the group to the left of the pivot (the closer houses). So, you can completely ignore the right group and only repeat the process on the left group.

You keep doing this—picking a pivot and splitting the list—on smaller and smaller portions of the list until you find a pivot that lands exactly in the kth position. At that moment, the first k elements in the list are guaranteed to be the k closest points. This method is efficient because, on average, it cuts the problem in half each time.





The main function kClosest starts the process. It calculates that we need the first k elements after a partial sort and calls the quickSelect helper function.

The quickSelect function is the core of the algorithm. It takes the list of points, a left index, a right index (defining the current search area), and k. If the search area is just one point, it returns. Otherwise, it calls the partition function.

The partition function does the heavy lifting. It chooses the last element as the pivot and calculates its squared distance. It then scans through all other points in the current range. Any point that is closer or at the same distance as the pivot is swapped to the left side of the list. The variable i keeps track of where the next "close" point should go. After the scan, the pivot is swapped into its correct position at index i. This function returns the final index i of the pivot.

Back in quickSelect, we check this pivot index. If it is exactly equal to k, our job is done. If k is smaller than the pivot index, it means our k closest points are all in the left section, so we recursively search there. If k is larger, we search in the right section. The getDistance helper function simply calculates the squared distance for a point, avoiding the slow square root operation.

