Nim Game



The intuition behind the Nim Game is actually quite simple when you think about it step by step. Imagine you and your friend are playing a game with a pile of stones. You can take one, two, or three stones on your turn. The goal is to take the last stone. If you think about the smallest cases first, with one, two, or three stones, you can just take them all and win immediately. With four stones, no matter what you do, your friend can take the remaining stones and win. If you take one stone, three remain and your friend takes all three. If you take two stones, two remain and your friend takes both. If you take three stones, one remains and your friend takes it. So four is a losing position.

Now think about what happens with five stones. If you take one stone, you leave four stones for your friend. We already know four is a losing position for the player whose turn it is. So by taking one stone from five, you force your friend into a losing position. This pattern continues. Any number that is not a multiple of four gives you a winning move because you can always take enough stones to leave your friend with a multiple of four stones. Six stones, take two to leave four. Seven stones, take three to leave four. Eight stones is like four stones again because no matter what you take, your friend can then take enough to leave you with four stones. So the key is that multiples of four are losing positions, and all other numbers are winning positions if you play perfectly.

The code solution uses a very simple check. It just looks at whether the number of stones is divisible by four. If it is divisible by four, you cannot win against optimal play. If it is not divisible by four, you can always win by making the right first move. The code returns true when n mod four is not zero, meaning n is not a multiple of four. This is all it needs because the mathematical pattern is consistent regardless of how large the pile gets. The modulo operation gives the remainder when dividing by four, and if that remainder is zero, you lose.
















Bulb Switcher




The intuition for the Bulb Switcher problem requires thinking about how many times each bulb gets toggled. First, all bulbs start off. In the first round, you turn on every bulb, so each bulb is toggled once. In the second round, you toggle every second bulb, meaning bulbs 2, 4, 6, and so on get toggled. In the third round, you toggle every third bulb, meaning bulbs 3, 6, 9, and so on. This continues until the nth round where you only toggle the nth bulb.

The important question is: when does a bulb end up on? A bulb ends up on if it is toggled an odd number of times. If it is toggled an even number of times, it ends up off. So we need to figure out which bulbs get toggled an odd number of times. When is a bulb toggled? Bulb number i is toggled in round k if k divides i evenly. For example, bulb 6 is toggled in rounds 1, 2, 3, and 6 because all these numbers divide 6. So the number of times bulb i is toggled equals the number of divisors i has.

Now, which numbers have an odd number of divisors? Most numbers have an even number of divisors because divisors usually come in pairs. For example, 12 has divisors 1 and 12, 2 and 6, 3 and 4. That is six divisors, an even number. However, perfect squares have an odd number of divisors because one divisor pairs with itself. For example, 9 has divisors 1 and 9, and 3 and 3. The divisor 3 is counted only once, so we have three divisors: 1, 3, and 9. So perfect squares have an odd number of divisors.

Therefore, only bulbs at perfect square positions will be toggled an odd number of times and will remain on at the end. Bulb 1, 4, 9, 16, and so on will be on. All other bulbs will be off. The question asks how many bulbs are on after n rounds. That is simply the number of perfect squares less than or equal to n. The number of perfect squares up to n is the integer part of the square root of n. For example, if n is 10, the perfect squares up to 10 are 1, 4, and 9. The square root of 10 is about 3.16, and the integer part is 3, so three bulbs are on.

The code solution takes advantage of this mathematical insight. Instead of simulating all the rounds, which would be extremely slow for large n, it simply calculates the square root of n and returns that integer value. The square root function gives a floating point number, but when stored in an integer variable in C++, it automatically truncates to the integer part. This gives exactly the number of perfect squares less than or equal to n, which is the number of bulbs that remain on. This approach is very efficient and works instantly even for very large values of n.