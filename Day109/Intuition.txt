To determine whether a number is a palindrome without converting it to a string, we need to think in terms of its digits. A number is a palindrome if it reads the same forward and backward. So, for instance, 121 is a palindrome because the digits at the start and end match, and the middle remains the same when reversed. A straightforward idea would be to reverse the entire number and compare it to the original. However, this can lead to issues like integer overflow for large numbers, and the problem specifically challenges us to solve it without using string conversion, which would be the easiest way.

Instead, we use a mathematical approach by reversing only half of the number. The core idea is that if the number is a palindrome, the first half should mirror the second half. So, we repeatedly take the last digit of the number and build a reversed number from it. We continue this until the original number becomes less than or equal to the reversed number. For example, for input 1221, we extract digits and form 1, then 12, while simultaneously reducing the original number to 12. At this point, both halves are equal, so the number is a palindrome.

There are a few edge cases we need to handle before even entering this process. Any negative number can never be a palindrome because the minus sign - only appears on the left and never at the end, so -121 will never match 121-. Similarly, any number ending in 0 cannot be a palindrome unless it is exactly 0, since a number like 10 becomes 01 when reversed, which isn't the same.

Finally, after reversing half of the number, we compare it with the remaining half. If the original number had even digits, both halves will be equal. If it had an odd number of digits, then the middle digit doesnâ€™t matter, so we simply discard the middle digit from the reversed half (by dividing by 10) and compare again. This way, we avoid extra space usage, prevent overflow issues, and achieve an efficient and clean solution that strictly works with integers