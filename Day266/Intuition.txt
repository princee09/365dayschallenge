367: Valid Perfect Square



Imagine you are trying to find out if a number, like 16, is a perfect square. A perfect square is a number you get when you multiply a whole number by itself. For example, 4 times 4 is 16, so 16 is a perfect square. The number 14 is not, because no whole number multiplied by itself equals 14.

The straightforward way would be to check every number from 1 up to the target number, squaring it to see if it matches. But for a very large number, this would be extremely slow, like searching for a name in a phone book by starting at the first page and reading every single entry.

Instead, we use a "Binary Search" strategy. Think of it as the most efficient way to search in a sorted phone book. You open the book right in the middle. If the name you're looking for comes alphabetically before the names on that page, you now know it must be in the first half of the book. You completely ignore the second half. You then take that first half, find its middle, and repeat the process. This way, you eliminate half of the remaining possibilities with every single step, finding the answer incredibly fast.

We apply this same logic to finding a square root. We know that if a number is a perfect square, its square root must lie somewhere between 1 and the number itself. We define a starting range. Then we repeatedly guess the middle number of that range. We square our guess. If the square is exactly equal to our target number, we found it. If the square is too big, we know the real answer must be smaller, so we adjust our range to only look at numbers lower than our guess. If the square is too small, we adjust our range to look only at numbers higher than our guess. We keep doing this until we either find the number or prove it doesn't exist.




The code starts by handling a simple case: if the number is 0 or 1, it is a perfect square, so we return true immediately.

It then sets up two pointers, left and right, which define the current search range. Initially, left is 2 and right is roughly half of the input number. This is because the square root of a number is always less than or equal to half of it (for numbers greater than 2).

The main loop runs as long as the left pointer has not passed the right pointer. Inside the loop, it calculates the mid point of the current range. It's very important to use a long type for mid and square to prevent a calculation error called integer overflow, which happens when you try to store a number that is too big for the variable type.

It then calculates the square of the mid value. It compares this square to the original number num. If they match, the answer is true. If the square is too large, it means mid is too big, so it moves the right pointer down to mid - 1. If the square is too small, it means mid is too small, so it moves the left pointer up to mid + 1.

If the loop finishes without finding a perfect square, the function returns false.

















441: Arranging Coins




Imagine you have a pile of coins and you want to build a staircase. The first step of the staircase needs 1 coin, the second step needs 2 coins, the third needs 3, and so on. You have a fixed number of coins. The question is, how many complete steps can you build?

For example, with 5 coins, you can build the first step (1 coin) and the second step (2 coins), using 3 coins in total. You have 2 coins left, which is not enough for the third step (which requires 3 coins), so you have 2 complete rows.

The number of coins needed to build 'k' complete rows is the sum of the first 'k' natural numbers: 1 + 2 + 3 + ... + k. There is a famous mathematical formula for this sum: k * (k + 1) / 2.

So, the problem becomes: find the largest whole number k for which the formula k * (k + 1) / 2 is less than or equal to your number of coins n.

Again, we can use our efficient "Binary Search" strategy. Our search space is all possible numbers of rows, from 0 up to n (you can't have more complete rows than you have coins). We guess a number of rows mid. We then use the formula to calculate how many coins would be needed for mid rows.

We compare this needed number to our actual number of coins n. If we need exactly n coins, we have found the perfect answer. If the needed coins are more than what we have, our guess mid is too high, and we must look for a smaller number of rows. If the needed coins are less than what we have, our guess mid might be correct, but maybe we can build even more rows, so we look for a larger number.






The code starts by setting the initial search range with left at 0 and right at n.

The loop continues as long as left is less than or equal to right. In each iteration, it finds the mid point. It then calculates coinsNeeded for mid rows using the formula (mid * (mid + 1)) / 2. Using long for these variables is crucial to avoid calculation errors with large numbers.

It compares coinsNeeded to n. If they are equal, it returns mid immediately. If too many coins are needed, it means mid is too large, so it reduces the search range by moving the right pointer down. If fewer coins are needed, it means we can potentially build more rows, so it moves the left pointer up.

When the loop ends, the left pointer has just passed the right pointer. The right pointer will be at the largest number of rows for which the coin sum does not exceed n. Therefore, the function returns right as the answer, which represents the number of complete rows.